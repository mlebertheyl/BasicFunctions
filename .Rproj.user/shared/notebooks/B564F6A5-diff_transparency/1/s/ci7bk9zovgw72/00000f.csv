"0","inla.barrier.fem.plus <- function (mesh, barrier.triangles) "
"0","  {"
"0","  n <- length(barrier.triangles) #barrier triangles list"
"0","  t <- length(mesh$graph$tv[, 1])"
"0","  total_triangles <- unlist(barrier.triangles)"
"0","  Omega <- list()"
"0","  Omega$remaining <- setdiff(1:t, total_triangles)"
"0","  for (k in 1:n) {"
"0","    Omega[k+1] <- barrier.triangles[k] "
"0","    names(Omega)[k+1] <- paste0(""barrier.triangles."", k)"
"0","  }"
"0","  "
"0","    dt.fem.white <- function(mesh, subdomain) {"
"0","        Ck <- rep(0, mesh$n)"
"0","        for (t in subdomain) {"
"0","            px <- mesh$graph$tv[t, ]"
"0","            temp <- mesh$loc[px, ]"
"0","            p1 <- t(t(temp[1, c(1, 2)]))"
"0","            p2 <- t(t(temp[2, c(1, 2)]))"
"0","            p3 <- t(t(temp[3, c(1, 2)]))"
"0","            Ts <- cbind(p2 - p1, p3 - p1)"
"0","            area <- abs(det(Ts)) * 0.5"
"0","            for (i in 1:3) {"
"0","                Ck[px[i]] <- Ck[px[i]] + area"
"0","            }"
"0","        }"
"0","        return(Ck)"
"0","    }"
"0","    dt.fem.identity <- function(mesh) {"
"0","        len <- length(mesh$graph$tv[, 1])"
"0","        index.i <- rep(0, len * 6)"
"0","        index.j <- rep(0, len * 6)"
"0","        #index.q <- rep(0, len * 6)"
"0","        Aij <- rep(0, len * 6)"
"0","        counter <- 1"
"0","        for (t in 1:len) {"
"0","            px <- mesh$graph$tv[t, ]"
"0","            temp <- mesh$loc[px, ]"
"0","            p1 <- t(t(temp[1, c(1, 2)]))"
"0","            p2 <- t(t(temp[2, c(1, 2)]))"
"0","            p3 <- t(t(temp[3, c(1, 2)]))"
"0","            Ts <- cbind(p2 - p1, p3 - p1)"
"0","            twiceArea <- abs(det(Ts))"
"0","            for (i in 1:3) {"
"0","                index.i[counter] <- px[i]"
"0","                index.j[counter] <- px[i]"
"0","                #index.q[counter] <- px[i]"
"0","                Aij[counter] <- (twiceArea) * 1/12"
"0","                counter <- counter + 1"
"0","            }"
"0","            for (i in 1:2) {"
"0","                for (j in (i + 1):3) {"
"0","                  index.i[counter] <- px[i]"
"0","                  index.j[counter] <- px[j]"
"0","                  Aij[counter] <- (twiceArea) * 1/24"
"0","                  counter <- counter + 1"
"0","                  index.i[counter] <- px[j]"
"0","                  index.j[counter] <- px[i]"
"0","                  Aij[counter] <- (twiceArea) * 1/24"
"0","                  counter <- counter + 1"
"0","                }"
"0","            }"
"0","        }"
"0","        I <- sparseMatrix(i = index.i, j = index.j, x = Aij, "
"0","            dims = c(mesh$n, mesh$n), repr = ""T"")"
"0","        return(I)"
"0","    }"
"0","    dt.fem.laplace <- function(mesh, subdomain) {"
"0","        Nphix <- rbind(c(-1, -1), c(1, 0), c(0, 1))"
"0","        len <- length(subdomain)"
"0","        index.i <- rep(0, len * 9)"
"0","        index.j <- rep(0, len * 9)"
"0","        Aij <- rep(0, len * 9)"
"0","        counter <- 1"
"0","        for (tri in subdomain) {"
"0","            px <- mesh$graph$tv[tri, ]"
"0","            temp <- mesh$loc[px, ]"
"0","            p1 <- t(t(temp[1, c(1, 2)]))"
"0","            p2 <- t(t(temp[2, c(1, 2)]))"
"0","            p3 <- t(t(temp[3, c(1, 2)]))"
"0","            Ts <- cbind(p2 - p1, p3 - p1)"
"0","            TTTinv <- solve(t(Ts) %*% Ts)"
"0","            area <- abs(det(Ts)) * 0.5"
"0","            for (k in 1:3) {"
"0","                for (m in 1:3) {"
"0","                  tmp <- (3 * m + k - 4) * length(subdomain)"
"0","                  index.i[(tmp + counter)] <- px[k]"
"0","                  index.j[(tmp + counter)] <- px[m]"
"0","                  Aij[(tmp + counter)] <- area * Nphix[k, c(1, "
"0","                    2)] %*% TTTinv %*% as.matrix(Nphix[m, c(1, "
"0","                    2)])"
"0","                }"
"0","            }"
"0","            counter <- counter + 1"
"0","        }"
"0","        Dk <- sparseMatrix(i = index.i, j = index.j, x = Aij, "
"0","            dims = c(mesh$n, mesh$n), repr = ""T"")"
"0","        return(Dk)"
"0","    }"
"0","    xi <- length(Omega)"
"0","        fem <- list()"
"0","        fem$I <- dt.fem.identity(mesh)"
"0","        fem$D <- list()"
"0","        fem$C <- list()"
"0","        for (k in 1:xi) {"
"0","            fem$D[[k]] <- dt.fem.laplace(mesh, Omega[[k]])"
"0","        }"
"0","        for (k in 1:xi) {"
"0","            fem$C[[k]] <- dt.fem.white(mesh, Omega[[k]])"
"0","        }"
"0","        fem$hdim <- xi"
"0","    "
"0","    return(fem)"
"0","}"
"0",""
"0","inla.barrier.q <- function (fem, ranges, sigma = 1, envir = NULL) "
"0","{"
"0","    if (is.null(ranges)) "
"0","        stop(""ranges cannot be NULL"")"
"0","    if (any(is.na(ranges))) "
"0","        stop(""No range can be NA"")"
"0","    xi <- length(ranges)"
"0","    if (xi != length(fem$D)) {"
"0","        print(""inla.barrier.q has encountered an error. Will stop."")"
"0","        stop(""Ranges do no correspond to fem"")"
"0","    }"
"0","    if (any(ranges < 0.001)) {"
"0","        warning(""This hyper parameter value may fail. A very small maximum edge length needed in the mesh."")"
"0","    }"
"0","    Cdiag <- ranges[1]^2 * fem$C[[1]]"
"0","    if (xi > 1) {"
"0","        for (k in 2:xi) {"
"0","            Cdiag <- Cdiag + ranges[k]^2 * fem$C[[k]]"
"0","        }"
"0","    }"
"0","    N <- length(Cdiag)"
"0","    Cinv <- sparseMatrix(i = 1:N, j = 1:N, x = 1/Cdiag, dims = c(N, "
"0","        N), repr = ""T"")"
"0","    A <- fem$I"
"0","    for (k in 1:xi) {"
"0","        A <- A + (ranges[k]^2/8) * fem$D[[k]]"
"0","    }"
"0","    Q <- inla.as.sparse(t(A) %*% Cinv %*% A * (1/sigma^2)/pi * "
"0","        2 * 3)"
"0","    if (is.environment(envir)) {"
"0","        if (!exists(""cache.done"", envir = envir)) {"
"0","            Qx.idx <- which(Q@i <= Q@j)"
"0","            assign(""Qx.idx"", Qx.idx, envir = envir)"
"0","            assign(""cache.done"", TRUE, envir = envir)"
"0","        }"
"0","        else {"
"0","            Qx.idx <- get(""Qx.idx"", envir = envir)"
"0","        }"
"0","        return(Q@x[Qx.idx])"
"0","    }"
"0","    else {"
"0","        return(Q)"
"0","    }"
"0","}"
"0",""
"0","inla.barrier.pcmatern.plus <- function (mesh, fem, barrier.triangles, prior.range, prior.sigma, range.fraction = 0.2) "
"0","{"
"0","    if (missing(prior.range)) {"
"0","        warning(""Arbitrary prior values chosen automatically. This may suffice for a first attempt, \n            but should be changed in any serious analysis."")"
"0","        prior.range <- c(diff(range(mesh$loc[, 1]))/5, 0.5)"
"0","    }"
"0","    if (missing(prior.sigma)) {"
"0","        prior.sigma <- c(1, 0.5) "
"0","    }"
"0","    stopifnot(inherits(mesh, ""inla.mesh""))"
"0","    stopifnot(range.fraction > 1e-06)"
"0","#    if (requireNamespace(""INLAspacetime"")) {"
"0","#        warning(""Using implementation from the `INLAspacetime` package"")"
"0","#        return(INLAspacetime::barrierModel.define(mesh = mesh, "
"0","#            barrier.triangles = barrier.triangles, prior.range = prior.range, "
"0","#            prior.sigma = prior.sigma, range.fraction = range.fraction))"
"0","#    }"
"0","#    else {"
"0","#        warning(paste(""Please install the `INLAspacetime` package\n"", "
"0","#            ""which contains an implementation that runs faster!""))"
"0","#    }"
"0","    barrier.rgeneric.model <- function(cmd = c(""graph"", ""Q"", "
"0","        ""mu"", ""initial"", ""log.norm.const"", ""log.prior"", ""quit""), "
"0","        theta = NULL) {"
"0","        envir = parent.env(environment())"
"0","        prior.sigma <- obj$prior.sigma"
"0","        prior.range <- obj$prior.range"
"0","        fem <- obj$fem"
"0","        inla.barrier.q <- obj$inla.barrier.q"
"0","        range.fraction <- obj$range.fraction"
"0","        initial <- function(theta) {"
"0","            initial.theta <- c()"
"0","            if (!is.na(prior.sigma[2])) {"
"0","                initial.theta <- c(0, initial.theta)"
"0","            }"
"0","            if (!is.na(prior.range[2])) {"
"0","                initial.theta <- c(initial.theta, 0)"
"0","            }"
"0","            return(initial.theta)"
"0","        }"
"0","        log.prior <- function(theta) {"
"0","            val <- 0"
"0","            if (!is.na(prior.sigma[2])) {"
"0","                lambda0 <- -log(prior.sigma[2])/prior.sigma[1]"
"0","                val <- val + log(lambda0) - lambda0 * exp(theta[1]) + "
"0","                  theta[1]"
"0","                theta.ran <- theta[-1]"
"0","            }"
"0","            else {"
"0","                theta.ran <- theta"
"0","            }"
"0","            if (!is.na(prior.range[2])) {"
"0","                lambda1 <- -log(prior.range[2]) * prior.range[1]"
"0","                for (logrange in theta.ran) {"
"0","                  val <- val + log(lambda1) - lambda1 * exp(-logrange) + "
"0","                    -logrange"
"0","                }"
"0","            }"
"0","            return(val)"
"0","        }"
"0","        Q <- function(theta) {"
"0","            theta.full <- theta"
"0","            if (is.na(prior.sigma[2])) {"
"0","                theta.full <- c(log(prior.sigma[1]), theta.full)"
"0","            }"
"0","            if (is.na(prior.range[2])) {"
"0","                theta.full <- c(theta.full, log(prior.range[1]))"
"0","            }"
"0","            stopifnot(length(theta.full) == 2)"
"0","            Q <- inla.barrier.q(fem = fem, ranges = exp(theta.full[2]) * "
"0","                c(1, range.fraction), sigma = exp(theta.full[1]), "
"0","                envir = envir) #ENVIR MAKES IT WORK"
"0","            return(Q)"
"0","        }"
"0","        graph <- function(theta) {"
"0","            require(methods)"
"0","            ntheta <- 2"
"0","            theta.full <- (1:ntheta)/3.217233456"
"0","            G1 <- inla.barrier.q(fem = fem, ranges = exp(theta.full[2]) * "
"0","                c(1, range.fraction), sigma = exp(theta.full[1]))"
"0","            G1[G1 != 0] <- 1"
"0","            theta.full <- (1:ntheta)^2/12.1543534"
"0","            G2 <- inla.barrier.q(fem = fem, ranges = exp(theta.full[2]) * "
"0","                c(1, range.fraction), sigma = exp(theta.full[1]))"
"0","            G2[G2 != 0] <- 1"
"0","            return(G1 + G2)"
"0","        }"
"0","        mu <- function(theta) numeric(0)"
"0","        log.norm.const <- function(theta) numeric(0)"
"0","        quit <- function(theta) invisible()"
"0","        val <- do.call(match.arg(cmd), args = list(theta))"
"0","        return(val)"
"0","    }"
"0","#   barrier.triangles <- unique(barrier.triangles)"
"0","    obj <- list()"
"0","    obj$prior.sigma <- prior.sigma"
"0","    obj$prior.range <- prior.range"
"0","    obj$range.fraction <- range.fraction"
"0","    obj$inla.barrier.q <- inla.barrier.q"
"0","    obj$fem <- fem"
"0","    barrier.model <- inla.rgeneric.define(model = barrier.rgeneric.model, "
"0","        optimize = TRUE, obj = obj)"
"0","    if (!is.na(prior.sigma[2]) && !is.na(prior.range[2])) {"
"0","    }"
"0","    else {"
"0","        warning(""Not properly tested, let us know if you have problems."")"
"0","    }"
"0","    return(barrier.model)"
"0","}"
"0",""
"0","# local.plot.field_ same as local.plot.field, but I can modify the color paltte."
"0",""
"0","library(wesanderson)"
"0","# inla.barrier.polygon(mesh_kmD, barrier.triangles = barrier)"
"0","# ~Documents/Research/BasicFunctions/TUTORIAL Simulation and Inference BM.Rmd"
"0","# from: https://haakonbakkagit.github.io/btopic103.html"
"0","local.plot.field_ = function(field, mesh, "
"0","                             xlim, ylim, "
"0","                             dims=c(300, 300), "
"0","                             pal, ...){"
"0","  if (missing(xlim)) {"
"0","        xlim = c(2, 8)"
"0","  }"
"0","  if (missing(ylim)) {"
"0","        ylim = xlim"
"0","  }"
"0","  if (missing(pal)) {"
"0","    pal = viridis::plasma(17)"
"0","  }"
"0","  "
"0","  proj = inla.mesh.projector(mesh, xlim = xlim, "
"0","                             ylim = ylim, dims=c(300, 300))"
"0","  # - Can project from the mesh onto a 300x300 grid "
"0","  #   for plots"
"0","  field.proj = inla.mesh.project(proj, field)"
"0","  # - Do the projection"
"0","  image.plot(list(x = proj$x, y=proj$y, z = field.proj), "
"0","             xlim = xlim, ylim = ylim, col = pal, ...)  "
"0","  # - Use image.plot to get nice colors and legend"
"0","}"
"0","# - This is the appropriate length of the field variable"
"0","# print(mesh_kmD$n)"
"0",""
"0","# pp has if(missing(xlim))..."
"0","local.plot.fieldpp = function(field, mesh, poly.water, xlim, ylim, zlim, "
"0","                              dims=c(300, 300),...){"
"0"," # poly.water = km_sp4msh, it has to be the SpatialPolygon object used in inla.mesh.2d"
"0"," # Error when using the wrong mesh"
"0"," stopifnot(length(field) == mesh$n)"
"0","    "
"0"," # Choose plotting region to be the same as the study area polygon"
"0"," if (missing(xlim)) xlim = poly.water@bbox[1, ] "
"0"," if (missing(ylim)) ylim = poly.water@bbox[2, ]"
"0","    "
"0"," # Project the mesh onto a 300x300 grid   "
"0"," proj = inla.mesh.projector(mesh, xlim = xlim,                              "
"0","                            ylim = ylim, dims=c(300, 300)) "
"0"," # Do the projection "
"0"," field.proj = inla.mesh.project(proj, field)"
"0","       "
"0"," # Plot it"
"0"," image.plot(list(x = proj$x, y=proj$y, z = field.proj), "
"0","               xlim = xlim, ylim = ylim, zlim = zlim, ...)  "
"0","  }"
"0",""
"0","library(fields)"
"0","library(viridisLite)"
"0","library(RColorBrewer)"
"0",""
"0","book.rMatern <- function(n, coords, sigma=1, range, kappa = sqrt(8*nu)/range, variance = sigma^2, nu=1) {"
"0","    m <- as.matrix(dist(coords))"
"0","    m <- exp((1-nu)*log(2) + nu*log(kappa*m)-"
"0","             lgamma(nu))*besselK(m*kappa, nu)"
"0","    diag(m) <- 1"
"0","    return(drop(crossprod(chol(variance*m),"
"0","                          matrix(rnorm(nrow(coords)*n), ncol=n))))"
"0","}"
"0",""
"0","book.rspde <- function(coords, sigma=1, range, variance=sigma^2, alpha=2, kappa = sqrt(8*(alpha-1))/range, n=1, mesh, "
"0","                  verbose=FALSE, seed, return.attributes=FALSE) {"
"0","    t0 <- Sys.time()"
"0","    theta <- c(-0.5*log(4*pi*variance*kappa^2), log(kappa))"
"0","    if (verbose) cat('theta =', theta, '\n')"
"0","    if (missing(mesh)) {"
"0","        mesh.pars <- c(0.5, 1, 0.1, 0.5, 1)*sqrt(alpha-ncol(coords)/2)/kappa "
"0","        if (verbose) cat('mesh.pars =', mesh.pars, '\n')"
"0","        attributes <- list("
"0","            mesh=inla.mesh.2d("
"0","                coords[chull(coords), ], max.edge=mesh.pars[1:2], "
"0","                cutoff=mesh.pars[3], offset=mesh.pars[4:5]))"
"0","        if (verbose) cat('n.mesh =', attributes$mesh$n, '\n')"
"0","    }"
"0","    else attributes <- list(mesh=mesh)"
"0","    attributes$spde <- inla.spde2.matern(attributes$mesh, alpha=alpha)"
"0","    attributes$Q <- inla.spde2.precision(attributes$spde, theta=theta)"
"0","    attributes$A <- inla.mesh.project(mesh=attributes$mesh, loc=coords)$A"
"0","    if (n==1) "
"0","        result <- drop(attributes$A%*%inla.qsample("
"0","            Q=attributes$Q,"
"0","            constr=attributes$spde$f$extraconstr))"
"0","    t1 <- Sys.time() "
"0","    result <- inla.qsample(n, attributes$Q, "
"0","                           seed=ifelse(missing(seed), 0, seed), "
"0","                           constr=attributes$spde$f$extraconstr) "
"0","    if (nrow(result)<nrow(attributes$A)) {"
"0","        result <- rbind(result, matrix("
"0","            NA, nrow(attributes$A)-nrow(result), ncol(result)))"
"0","        dimnames(result)[[1]] <- paste('x', 1:nrow(result), sep='')"
"0","        for (j in 1:ncol(result)) "
"0","            result[, j] <- drop(attributes$A%*%"
"0","                                result[1:ncol(attributes$A),j])"
"0","    }"
"0","    else {"
"0","        for (j in 1:ncol(result)) "
"0","            result[1:nrow(attributes$A), j] <-"
"0","                drop(attributes$A%*%result[,j]) "
"0","        result <- result[1:nrow(attributes$A), ]"
"0","    }"
"0","    t2 <- Sys.time()"
"0","    attributes$cpu <- c(prep=t1-t0, sample=t2-t1, total=t2-t0)"
"0","    if (return.attributes) "
"0","        attributes(result) <- c(attributes(result), attributes)"
"0","    return(drop(result))"
"0","}"
"0",""
"0","book.mesh.dual <- function(mesh) {"
"0","    if (mesh$manifold=='R2') {"
"0","        ce <- t(sapply(1:nrow(mesh$graph$tv), function(i)"
"0","            colMeans(mesh$loc[mesh$graph$tv[i, ], 1:2])))"
"0","        library(parallel)"
"0","        pls <- mclapply(1:mesh$n, function(i) {"
"0","            p <- unique(Reduce('rbind', lapply(1:3, function(k) {"
"0","                j <- which(mesh$graph$tv[,k]==i)"
"0","                if (length(j)>0) "
"0","                    return(rbind(ce[j, , drop=FALSE],"
"0","                                 cbind(mesh$loc[mesh$graph$tv[j, k], 1] +"
"0","                                       mesh$loc[mesh$graph$tv[j, c(2:3,1)[k]], 1], "
"0","                                       mesh$loc[mesh$graph$tv[j, k], 2] +"
"0","                                       mesh$loc[mesh$graph$tv[j, c(2:3,1)[k]], 2])/2))"
"0","                else return(ce[j, , drop=FALSE])"
"0","            })))"
"0","            j1 <- which(mesh$segm$bnd$idx[,1]==i)"
"0","            j2 <- which(mesh$segm$bnd$idx[,2]==i)"
"0","            if ((length(j1)>0) | (length(j2)>0)) {"
"0","                p <- unique(rbind(mesh$loc[i, 1:2], p,"
"0","                                  mesh$loc[mesh$segm$bnd$idx[j1, 1], 1:2]/2 +"
"0","                                  mesh$loc[mesh$segm$bnd$idx[j1, 2], 1:2]/2, "
"0","                                  mesh$loc[mesh$segm$bnd$idx[j2, 1], 1:2]/2 +"
"0","                                  mesh$loc[mesh$segm$bnd$idx[j2, 2], 1:2]/2))"
"0","                yy <- p[,2]-mean(p[,2])/2-mesh$loc[i, 2]/2"
"0","                xx <- p[,1]-mean(p[,1])/2-mesh$loc[i, 1]/2"
"0","            }"
"0","            else {"
"0","                yy <- p[,2]-mesh$loc[i, 2]"
"0","                xx <- p[,1]-mesh$loc[i, 1]"
"0","            }"
"0","            Polygon(p[order(atan2(yy,xx)), ])"
"0","        })"
"0","        return(SpatialPolygons(lapply(1:mesh$n, function(i)"
"0","            Polygons(list(pls[[i]]), i))))"
"0","    }"
"0","    else stop(""It only works for R2!"")"
"0","}"
"0",""
"0","genColor <- function(n, type=c('red', 'green', 'blue'), u=NULL) {"
"0","    cbp <- list("
"0","        red = list(c(255, 254, 252, 252, 251, 239, 203, 165, 103), "
"0","                   c(245, 224, 187, 146, 106, 59, 24, 15, 0), "
"0","                   c(240, 210, 161, 114, 74, 44, 29, 21, 13)), "
"0","        green = list(c(247, 229, 199, 161, 116, 65, 35, 0, 0), "
"0","                     c(252, 245, 233, 217, 196, 171, 139, 109, 68), "
"0","                     c(245, 224, 192, 155, 118, 93, 69, 44, 27)), "
"0","        blue = list(c(247, 222, 198, 158, 107, 66, 33, 8, 8), "
"0","                    c(251, 235, 219, 202, 174, 146, 113, 81, 48), "
"0","                    c(255, 247, 239, 225, 214, 198, 181, 156, 107)))"
"0","    if (n<2) stop(""Works for 'n>2'!"")"
"0","    if (is.null(u))"
"0","        u <- 0:(n-1)/(n-1)"
"0","    u0 <- 0:8/8"
"0","    i <- findInterval(u, u0, TRUE)"
"0","    k <- pmatch(match.arg(type), c('red', 'green', 'blue'))"
"0","    w1 <- 8*(u0[i+1]-u)/255; w2 <- 8*(u-u0[i])/255"
"0","    rgb(cbp[[k]][[1]][i]*w1 + cbp[[k]][[1]][i+1]*w2, "
"0","        cbp[[k]][[2]][i]*w1 + cbp[[k]][[2]][i+1]*w2, "
"0","        cbp[[k]][[3]][i]*w1 + cbp[[k]][[3]][i+1]*w2)"
"0","}"
"0",""
"0","plot.dgTMatrix <- function(x, y, ...) {"
"0","    cl <- match.call()"
"0","    if (is.null(cl$digits))"
"0","        digits <- 2"
"0","    z <- sort(unique(round(x@x, digits)))"
"0","    nz <- length(z)"
"0","    n1 <- sum(z<0)"
"0","    n2 <- sum(z>0)"
"0","    if (is.null(cl$colors)) "
"0","        if (any(c(n1,n2)==0)) "
"0","            colors <- gray(0.9*(1-(z-min(z))/diff(range(z))))"
"0","        else"
"0","            colors <- c(genColor(n1, 'red', z[z<0]/min(z)),"
"0","                        rep('white', nz-n1-n2),"
"0","                        genColor(n2, 'blue', z[z>0]/max(z)))"
"0","    z.breaks <- c(z[1]-diff(z[1:2])/2,"
"0","                  z[-nz]/2 + z[-1]/2,"
"0","                  z[nz]+diff(z[nz-1:0])/2)"
"0","    x@x <- round(x@x, digits)"
"0","    image(x, at=z.breaks, col.regions=colors, ...)"
"0","}"
"0",""
"0","book.plot.field <- function(field, mesh, projector, xlim, ylim, "
"0","			    dims=c(300,300), poly, asp = 1, "
"0","			    axes = FALSE, xlab = '', ylab = '', "
"0","			    col = book.color.c(), ...){"
"0","  ## you can supply field as a matrix vector or like a named list with 'x', 'y' and 'z' as for image"
"0","  ## when field is a vector, it will project it using projector, assuming projector will create a matrix "
"0","  ## when mesh is supplied and projector not, projector will be created and used to project field"
"0","  if (missing(mesh)) {"
"0","    if (missing(projector)) {"
"0","      if (missing(xlim) | missing(ylim)) {"
"0","        image.plot(field, asp = asp, axes = axes, "
"0","                   xlab = xlab, ylab = ylab, col = col, ...)"
"0","      } else {"
"0","        image.plot(field, xlim = xlim, ylim = ylim, asp = asp, "
"0","                   axes = axes, xlab = xlab, ylab = ylab, col = col, ...)"
"0","      }"
"0","    } else {"
"0","      if (missing(xlim)) xlim <- range(projector$x)"
"0","      if (missing(ylim)) ylim <- range(projector$y)"
"0","      field.proj <- inla.mesh.project(projector, field)"
"0","      image.plot(x = projector$x, y = projector$y, z = field.proj, "
"0","                 asp=asp, axes=axes, xlab = xlab, ylab = ylab, "
"0","                 col=col, xlim=xlim, ylim=ylim, ...)"
"0","    }"
"0","  } else {"
"0","    if (missing(xlim)) xlim <- range(mesh$loc[,1])"
"0","    if (missing(ylim)) ylim <- range(mesh$loc[,2])"
"0","    projector <- inla.mesh.projector(mesh, xlim = xlim,"
"0","                                     ylim = ylim, dims=dims)"
"0","    field.proj <- inla.mesh.project(projector, field)"
"0","    image.plot(x = projector$x, y = projector$y, z = field.proj, "
"0","               asp=asp, axes=axes, xlab = xlab, ylab = ylab, col=col, ...)"
"0","  }"
"0","  if (!missing(poly)) "
"0","      plot(poly, add = TRUE, col = 'grey')"
"0","}"
"0",""
"0","## Functions for barrier models"
"0",""
"0","## Find the correlation of precision Q (defined on mesh) at location "
"0","book.spatial.correlation <- function(Q, location, mesh) {"
"0","  ## The marginal standard deviations"
"0","  sd <- sqrt(diag(inla.qinv(Q)))"
"0",""
"0","  ## Create a fake A matrix, to extract the closest mesh node index"
"0","  A.tmp <- inla.spde.make.A(mesh = mesh,"
"0","    loc = matrix(c(location[1], location[2]), 1, 2))"
"0","  id.node = which.max(A.tmp[1, ])"
"0",""
"0","  ## Solve a matrix system to find just one column of the covariance matrix"
"0","  Inode <- rep(0, dim(Q)[1])"
"0","  Inode[id.node] <- 1"
"0","  covar.column <- solve(Q, Inode)"
"0","  corr <- drop(matrix(covar.column)) / (sd * sd[id.node])"
"0","  return(corr)"
"0","}"
"0",""
"0","## Continuous and discrete colour scales for the book"
"0","# n=8; plot(1:n, col=brewer.pal(n = n, name = ""Paired""))"
"0",""
"0","# Continuous"
"0","book.color.c = function(n = 201) {"
"0","  return(viridis(n))"
"0","}"
"0",""
"0","# Continuous (alternative)"
"0","book.color.c2 = function(n = 201) {"
"0","  return(magma(n))"
"0","}"
"0",""
"0","# Discrete from a continuous"
"0","book.color.dc = function(n = 11) {"
"0","  return(viridis(n))"
"0","}"
"0",""
"0","# Discrete (cannot be interpolated)"
"0","book.color.d = function(n=4) {"
"0","  return(brewer.pal(n = n, name = ""Paired""))"
"0","}"
"0",""
