"0","inla.barrier.q.plus <- function (fem, ranges, sigma = 1) "
"0","{"
"0","    if (is.null(ranges)) "
"0","        stop(""ranges cannot be NULL"")"
"0","    if (any(is.na(ranges))) "
"0","        stop(""No range can be NA"")"
"0","    xi <- length(ranges)"
"0","    if (xi != length(fem$D)) {"
"0","        print(""inla.barrier.q has encountered an error. Will stop."")"
"0","        stop(""Ranges do no correspond to fem"")"
"0","    }"
"0","    if (any(ranges < 0.001)) {"
"0","        warning(""This hyper parameter value may fail. A very small maximum edge length needed in the mesh."")"
"0","    }"
"0","    Cdiag <- ranges[1]^2 * fem$C[[1]]"
"0","    if (xi > 1) {"
"0","        for (k in 2:xi) {"
"0","            Cdiag <- Cdiag + ranges[k]^2 * fem$C[[k]] ##eq (9) "
"0","        }"
"0","    }"
"0","    N <- length(Cdiag)"
"0","    Cinv <- sparseMatrix(i = 1:N, j = 1:N, x = 1/Cdiag, dims = c(N, "
"0","        N), repr = ""T"")"
"0","    A <- fem$I"
"0","    for (k in 1:xi) {"
"0","        A <- A + (ranges[k]^2/8) * fem$D[[k]]"
"0","    }"
"0","    Q <- inla.as.sparse(t(A) %*% Cinv %*% A * (1/sigma^2)/pi * "
"0","        2 * 3)"
"0","#    if (is.environment(envir)) {"
"0","#        if (!exists(""cache.done"", envir = envir)) {"
"0","#            Qx.idx <- which(Q@i <= Q@j)"
"0","#            assign(""Qx.idx"", Qx.idx, envir = envir)"
"0","#            assign(""cache.done"", TRUE, envir = envir)"
"0","#        }"
"0","#        else {"
"0","#            Qx.idx <- get(""Qx.idx"", envir = envir)"
"0","#        }"
"0","#        return(Q@x[Qx.idx])"
"0","#    }"
"0","#    else {"
"0","        return(Q)"
"0","#    }"
"0","  }"
"0",""
