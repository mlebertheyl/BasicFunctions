"0","#Do not run"
"0","#option 1: list with 3 obj. Same barrier taken as 2 different ones."
"0","inla.barrier.fem <- function (mesh, barrier.triangles, Omega = NULL) "
"0","  {"
"0","    stopifnot(inherits(mesh, ""inla.mesh""))"
"0","    if (missing(barrier.triangles) && is.null(Omega)) "
"0","        stop(""Input barrier triangles"")"
"0","    if (missing(barrier.triangles)) {"
"0","    }"
"0","    else {"
"0","        #barrier.triangles <- unique(barrier.triangles) "
"0","        barrier.triangles.h <- barrier.triangles #layer with higher prob."
"0","        barrier.triangles.l <- barrier.triangles #layer with lower prob"
"0","        t <- length(mesh$graph$tv[, 1])"
"0","        remaining <- setdiff(1:t, barrier.triangles) # me quedo con los triangulos que sirven."
"0","        if (!is.null(Omega)) "
"0","            warning(""Omega is replaced by barrier.triangles"")"
"0","        #triangles separated in lists. Prev code (next), with only 2 obj."
"0","        #Omega <- list(remaining, barrier.triangles) "
"0","        Omega <- list(remaining, barrier.triangles.h, barrier.triangles.l) #option 1"
"0","        #option 1: list with 3 obj. Same barrier taken as 2 different ones."
"0","        #option 2: list with 2 obj. Maybe lower and higher prob triangles can be contain in the same list?"
"0","    }"
"0","  "
"0","    dt.fem.white <- function(mesh, subdomain) {"
"0","        Ck <- rep(0, mesh$n)"
"0","        for (t in subdomain) {"
"0","            px <- mesh$graph$tv[t, ]"
"0","            temp <- mesh$loc[px, ]"
"0","            p1 <- t(t(temp[1, c(1, 2)]))"
"0","            p2 <- t(t(temp[2, c(1, 2)]))"
"0","            p3 <- t(t(temp[3, c(1, 2)]))"
"0","            Ts <- cbind(p2 - p1, p3 - p1)"
"0","            area <- abs(det(Ts)) * 0.5"
"0","            for (i in 1:3) {"
"0","                Ck[px[i]] <- Ck[px[i]] + area"
"0","            }"
"0","        }"
"0","        return(Ck)"
"0","    }"
"0","    dt.fem.identity <- function(mesh) {"
"0","        len <- length(mesh$graph$tv[, 1])"
"0","        #index.i <- rep(0, len * 6)"
"0","        index.i <- rep(0, len * 6)"
"0","        #index.j <- rep(0, len * 6)"
"0","        index.j <- rep(0, len * 6)"
"0","        i.q <- rep(0, len * 6)"
"0","        #Aij <- rep(0, len * 6)"
"0","        Aijq <- rep(0, len * 6)"
"0","        counter <- 1"
"0","        for (t in 1:len) {"
"0","            px <- mesh$graph$tv[t, ]"
"0","            temp <- mesh$loc[px, ]"
"0","            p1 <- t(t(temp[1, c(1, 2)]))"
"0","            p2 <- t(t(temp[2, c(1, 2)]))"
"0","            p3 <- t(t(temp[3, c(1, 2)]))"
"0","            Ts <- cbind(p2 - p1, p3 - p1)"
"0","            twiceArea <- abs(det(Ts))"
"0","            for (i in 1:3) {"
"0","                index.i[counter] <- px[i]"
"0","                index.j[counter] <- px[i]"
"0","                i.q[cpunter] <- px[i]"
"0","                #Aij[counter] <- (twiceArea) * 1/12"
"0","                Aijq[counter] <- (twiceArea) * 1/12"
"0","                counter <- counter + 1"
"0","            }"
"0","            for (i in 1:2) {"
"0","                for (j in (i + 1):3) {"
"0","                  index.i[counter] <- px[i]"
"0","                  index.j[counter] <- px[j]"
"0","                  Aij[counter] <- (twiceArea) * 1/24"
"0","                  counter <- counter + 1"
"0","                  index.i[counter] <- px[j]"
"0","                  index.j[counter] <- px[i]"
"0","                  Aij[counter] <- (twiceArea) * 1/24"
"0","                  counter <- counter + 1"
"0","                }"
"0","            }"
"0","        }"
"0","        I <- sparseMatrix(i = index.i, j = index.j, x = Aij, "
"0","            dims = c(mesh$n, mesh$n), repr = ""T"")"
"0","        return(I)"
"0","    }"
"0","    dt.fem.laplace <- function(mesh, subdomain) {"
"0","        Nphix <- rbind(c(-1, -1), c(1, 0), c(0, 1))"
"0","        len <- length(subdomain)"
"0","        index.i <- rep(0, len * 9)"
"0","        index.j <- rep(0, len * 9)"
"0","        Aij <- rep(0, len * 9)"
"0","        counter <- 1"
"0","        for (tri in subdomain) {"
"0","            px <- mesh$graph$tv[tri, ]"
"0","            temp <- mesh$loc[px, ]"
"0","            p1 <- t(t(temp[1, c(1, 2)]))"
"0","            p2 <- t(t(temp[2, c(1, 2)]))"
"0","            p3 <- t(t(temp[3, c(1, 2)]))"
"0","            Ts <- cbind(p2 - p1, p3 - p1)"
"0","            TTTinv <- solve(t(Ts) %*% Ts)"
"0","            area <- abs(det(Ts)) * 0.5"
"0","            for (k in 1:3) {"
"0","                for (m in 1:3) {"
"0","                  tmp <- (3 * m + k - 4) * length(subdomain)"
"0","                  index.i[(tmp + counter)] <- px[k]"
"0","                  index.j[(tmp + counter)] <- px[m]"
"0","                  Aij[(tmp + counter)] <- area * Nphix[k, c(1, "
"0","                    2)] %*% TTTinv %*% as.matrix(Nphix[m, c(1, "
"0","                    2)])"
"0","                }"
"0","            }"
"0","            counter <- counter + 1"
"0","        }"
"0","        Dk <- sparseMatrix(i = index.i, j = index.j, x = Aij, "
"0","            dims = c(mesh$n, mesh$n), repr = ""T"")"
"0","        return(Dk)"
"0","    }"
"0","    xi <- length(Omega)"
"0","    if (requireNamespace(""INLAspacetime"")) {"
"0","        warning(""Using implementation from the `INLAspacetime` package"")"
"0","        fem <- INLAspacetime::mesh2fem.barrier(mesh = mesh, barrier.triangles = Omega[[2L]])"
"0","    }"
"0","    else {"
"0","        warning(paste(""Please install the `INLAspacetime` package\n"", "
"0","            ""which contains an implementation that runs faster!""))"
"0","        fem <- list()"
"0","        fem$I <- dt.fem.identity(mesh)"
"0","        fem$D <- list()"
"0","        fem$C <- list()"
"0","        for (k in 1:xi) {"
"0","            fem$D[[k]] <- dt.fem.laplace(mesh, Omega[[k]])"
"0","        }"
"0","        for (k in 1:xi) {"
"0","            fem$C[[k]] <- dt.fem.white(mesh, Omega[[k]])"
"0","        }"
"0","        fem$hdim <- xi"
"0","    }"
"0","    return(fem)"
"0","}"
